.. _kotlin-property-annotations:

=================================
Property Annotations - Kotlin SDK
=================================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

This page describes the property annotations that you can use to customize
the behavior of properties in your Realm :ref:`object models <kotlin-object-schema>`.

The Kotlin SDK provides several annotations that add functionality to 
Realm object properties. Refer also to the `Annotations API reference 
<{+kotlin-local-prefix+}io.realm.kotlin.types.annotations/index.html>`__.

.. note:: Property Declarations

  In Kotlin, value types are implicitly non-nullable. You can declare 
  properties optional (nullable) using the built-in ``?`` Kotlin operator.
  Or you can assign a default value to a property in the property declaration.
  Refer to the :ref:`<kotlin-data-types>` for examples.

Examples on this page refer to the following ``User`` class:

.. literalinclude:: /examples/generated/kotlin/Schema.snippet.example-property-annotations.kt
  :language: kotlin

.. _kotlin-primary-keys:

Specify a Primary Key
---------------------

A **primary key** is a unique identifier for an object in a realm. No other 
objects of the same type can share an object's primary key.

To specify a property as the object type's primary key, use the `@PrimaryKey 
<{+kotlin-local-prefix+}io.realm.kotlin.types.annotations/-primary-key/index.html>`__
annotation:

.. literalinclude:: /examples/generated/kotlin/Schema.snippet.example-primary-key.kt  
  :language: kotlin

Important aspects of primary keys:

- You can define only one primary key per object schema.
- You *cannot* change the primary key field for an object type after
  adding any object of that type to a realm.
- Primary key values must be unique across all instances of an object
  in a realm. Attempting to insert a duplicate primary key value results
  in an error.
- Primary key values are immutable. To change the primary key value of
  an object, you must delete the original object and insert a new object
  with a different primary key value.
- Primary keys are nullable. However, because primary key values must be unique, 
  ``null`` can only be the primary key of one object in a collection.
- Realm automatically indexes primary keys, so you can efficiently 
  read and modify objects based on their primary key.

You can create a primary key with any of the following types:

- ``String``
- ``Byte``
- ``Char``
- ``Short``
- ``Int``
- ``Long``
- ``ObjectId``
- ``RealmUUID``
 
.. _kotlin-remap-a-property:

Map a Property or Class to a Different Name
-------------------------------------------

.. versionadded:: 10.8.0 Remap class names with @PersistedName

By default, Realm uses the name defined in the Kotlin model class to 
represent classes and fields internally. In some cases, you might want 
to define a different **persisted name** to the realm than the name 
used in your code:

- To make it easier to work across platforms where naming conventions differ. 
  For example, if your Device Sync schema property names use snake case, 
  while your project uses camel case.
- To change a class or property name in Kotlin without forcing a :ref:`migration <kotlin-migrations>`.
- To support multiple model classes with the same simple name in different packages.
- To use a class name that is longer than the 57-character limit enforced by Realm.

To map a Kotlin class or property name in your code to a different 
name to persist in the realm:  

#. Use the `@PersistedName 
   <{+kotlin-local-prefix+}io.realm.kotlin.types.annotations/-persisted-name/index.html>`__
   annotation on the Kotlin class or property. 
#. Specify the class or property ``name`` that you want persisted to the realm. 

.. tabs::

   .. tab:: Remap a Class
      :tabid: class-persisted-name

      In this example, ``Employee`` is the Kotlin class name used in the code 
      throughout the project to perform CRUD operations, and ``User`` is the
      persisted name to used to store objects in a realm:

      .. literalinclude:: /examples/generated/kotlin/Schema.snippet.example-persisted-class.kt
        :language: kotlin

      .. important:: Querying by Remapped Class Names
        
          When querying an inverse relationship on an object with a 
          remapped class name, you must use the persisted class name.
          For more information, refer to 
          :ref:`<kotlin-query-inverse-relationships>`.

   .. tab:: Remap a Property
      :tabid: property-persisted-name

      In this example, ``office`` is the Kotlin property name used in the code 
      throughout the project to perform CRUD operations, and ``office_location`` 
      is the persisted name used to store values in a realm:

      .. literalinclude:: /examples/generated/kotlin/Schema.snippet.example-persisted-property.kt
        :language: kotlin

      .. tip:: Querying by Remapped Property Names
        
        You can query by both the Kotlin property name used in the code and 
        by the persisted name stored in the realm.

If you write to a synced realm, the Sync schema sees the values stored using the 
persisted class or property name. Note the following: 

- Migrations *must* use the persisted class or property name
- Any reported schema errors use the persisted name


.. _kotlin-ignore:

Ignore Properties from Realm Schema
-----------------------------------

By default, Realm manages properties defined in your Realm object model. 
However, you can choose to ignore properties that you don't want to persist in 
a realm. 

To ignore a property and prevent it from persisting in a realm or being included
in the ``RealmObject`` :ref:`object schema <kotlin-object-schema>`, use the 
`@Ignore <{+kotlin-local-prefix+}io.realm.kotlin.types.annotations/-ignore/index.html>`__
annotation:

.. literalinclude:: /examples/generated/kotlin/Schema.snippet.example-ignore.kt
  :language: kotlin

Unlike managed properties, which are stored or updated in the database, 
ignored properties are *not* stored to the database. Ignored properties behave 
exactly like managed properties, except that they can't be used in queries 
and don't trigger Realm notifications.
 
You can mix managed and ignored properties within a class. 

.. _kotlin-indices:

Index Properties
----------------

Indexes are special data structures that store a small portion of a realm's data
in an easy to traverse form. The index stores the value of a specific field
ordered by the value of the field. The ordering of the index entries supports
efficient equality matches and range-based query operations. 
Note that indexes speed up some queries at the cost of slightly slower write 
times and additional storage and memory overhead. Realm stores indexes on disk,
which makes your realm files larger. Each index entry is
a minimum of 12 bytes.

To create an index on a property, use the `@Index
<{+kotlin-local-prefix+}io.realm.kotlin.types.annotations/-index/index.html>`__
annotation in the :ref:`object schema <kotlin-object-schema>`:

.. literalinclude:: /examples/generated/kotlin/Schema.snippet.declare-properties.kt
  :language: kotlin

.. note:: 

   :ref:`Primary keys <kotlin-primary-keys>` are indexed by default.

You *cannot* combine standard indexes and full-text indexes on the same property. 
To use full-text search indexes on a property, refer to the :ref:`<kotlin-fts-index>` 
section.

You can index fields with the following types:

- ``String``
- ``Byte``
- ``Short``
- ``Int``
- ``Long``
- ``Boolean``
- ``RealmInstant``
- ``ObjectId``
- ``RealmUUID``

.. _kotlin-fts-index:

Full-Text Search Indexes
------------------------

In addition to standard indexes, Realm also supports Full-Text Search 
(FTS) indexes on ``String`` properties. While you can query a string 
field with or without a standard index, an FTS index enables searching 
for multiple words and phrases and excluding others.

To create an FTS index to enable full-text queries on a property, use 
the `@FullText
<{+kotlin-local-prefix+}io.realm.kotlin.types.annotations/-full-text/index.html>`__ 
annotation:

.. literalinclude:: /examples/generated/kotlin/Schema.snippet.example-full-text.kt
  :language: kotlin

Note the following constraints on FTS indexes:

- FTS indexes are only valid for fields with ``String`` types.
- You *cannot* combine FTS indexes and standard indexes on the same property. 
  To use standard indexes on a property, refer to the :ref:`<kotlin-indices>` 
  section.

.. note:: Character Limitations for Full-Text Search Indexes

  For Full-Text Search (FTS) indexes, only ASCII and Latin-1 alphanumerical 
  chars (most western languages) are included in the index. 
  
  Indexes are diacritics- and case-insensitive.

For more information on querying full-text indexes, refer to 
:ref:`Filter with Full Text Search <kotlin-filter-fts>`.
